<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Aptos学习资源</title>
      <link href="/2024/06/22/%E5%8C%BA%E5%9D%97%E9%93%BE/Aptos%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
      <url>/2024/06/22/%E5%8C%BA%E5%9D%97%E9%93%BE/Aptos%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Aptos学习资源"><a href="#Aptos学习资源" class="headerlink" title="Aptos学习资源"></a>Aptos学习资源</h1><h2 id="我的整理"><a href="#我的整理" class="headerlink" title="我的整理"></a>我的整理</h2><ul><li>Aptos入门研报 [<a href="https://404ll.github.io/2024/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Move-on-Aptos-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%85%A5%E9%97%A8/">Move on Aptos 初入门-研报 | Elemen的象牙塔 (404ll.github.io)</a>]</li></ul><h2 id="共学营学员资料"><a href="#共学营学员资料" class="headerlink" title="共学营学员资料"></a>共学营学员资料</h2><blockquote><p>以下收录了Move On Aptos 共学营的全部资料</p></blockquote><ul><li><a href="https://alcove-pro.notion.site/Move-on-Aptos-alcove-bc0e60f57caa4f2195e06f89bfaedf8e?pvs=4">Notion资料</a> 这个资料包括了新手入门的了解和各种文档，以及课程的代码</li><li><a href="https://drive.google.com/drive/folders/1-EmZXvuPuVH60XmbmFxUg1jDm6-uDDG2">Google 云盘共学视频</a> 视频包括了Move语法的学习和实战，节奏很慢，适合学习</li><li><a href="https://aptos.dev/">Aptos开发者文档</a> 文档比较详细的说明了如何安装环境和一些进阶语法，英文版可以配合谷歌浏览器的自动翻译</li></ul><p>还有一段共学老师说的话，我觉得很有道理，所以分享出来:</p><p>“刚学一门语言会遇到很多新的语法和新的库接口，这是一定的。</p><p>最好的方法是把代码逐行解读，把每一行弄懂（可以通过写注释，或者打印在纸上），这样坚持看 3 个项目的源码，就可以自己仿照着写项目了。</p><p>写项目的时候又会遇到一些新的需求，就需要去看文档&#x2F;源码，等项目做出来了，这个时候你对一个语言的基本世界观就形成了。</p><p>学新语言，忌求快。</p><p>时刻牢记，慢就是快。”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Aptos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Move on Aptos 初入门-研报</title>
      <link href="/2024/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Move-on-Aptos-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%85%A5%E9%97%A8/"/>
      <url>/2024/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Move-on-Aptos-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>研报前言： 如有引用，文章结尾yml会附上相关文章的来源，同时会写出信息源便于读者证实，同时希望可以给投研新手提供一些帮助。</p></blockquote><h1 id="Move-on-Aptos-初入门"><a href="#Move-on-Aptos-初入门" class="headerlink" title="Move on Aptos - 初入门"></a>Move on Aptos - 初入门</h1><hr><h2 id="什么是-Aptos-？"><a href="#什么是-Aptos-？" class="headerlink" title="什么是 Aptos ？"></a>什么是 Aptos ？</h2><p>Aptos 是一个新兴的Layer1公链，脱胎于 Meta 的 Diem 和 Novi 项目，采用PoS（权益证明）机制，原生集成并使用 <em>Move 语言</em> 。Aptos 的设计注重安全性和可扩展性，通过独特的共识算法和并行执行技术，实现了高吞吐量、低延迟、安全可靠的特点。</p><p>Aptos 的目标是为开发者提供一个高效、安全、可扩展的区块链平台，推动区块链技术的进一步发展和应用。</p><h2 id="受人关注的技术亮点"><a href="#受人关注的技术亮点" class="headerlink" title="受人关注的技术亮点"></a>受人关注的技术亮点</h2><ul><li>采用Move语言</li><li>实现Aptos Keyless</li></ul><p>（Aptos创新性的技术远远不止这些，我只选取了部分技术进行解读）</p><p>这些技术的引进，使得Aptos在其他同类公链中获得了一定的竞争优势。</p><p>接下来让我们具体看看这些技术架构：</p><h2 id="全新的智能合约语言-Move"><a href="#全新的智能合约语言-Move" class="headerlink" title="全新的智能合约语言-Move"></a>全新的智能合约语言-Move</h2><p>Move是Meta为区块链开发量身定制的专有语言，Aptos 区块链从 Diem 区块链中继承使用并不断发展 Move。</p><h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a><strong>语言特点</strong></h3><p>Move语言是一种面向对象编程的语言，比较贴切地形容为“资源为一等公民”，Move 强调了资源的稀缺性、保存和访问控制，在Move语言中，资源（resources）是一种特殊的数据类型，表示对外部资源（如文件、网络连接等）的引用和操作，具有可复制 （ copy )、可索引 ( key )、可毁灭 ( drop )、可储存 ( store )等四个不同的属性。</p><p>通过进一步的学习，我认为与目前通用的智能合约语言（solidity，Rust)相比，Move语言上手的门槛相对较低， 它的语法更加的简单，编程模型也更加易懂。在实际编写的过程中比较突出的一点是：Move语言主要采用Module模型，在提高了组合性的同时使得系统的升级和优化变得更加简单。</p><h2 id="简化用户进入Web3世界-Aptos-Keyless"><a href="#简化用户进入Web3世界-Aptos-Keyless" class="headerlink" title="简化用户进入Web3世界-Aptos Keyless"></a>简化用户进入Web3世界-Aptos Keyless</h2><p>最近，账户抽象新标准—Aptos Keyless 正式在Aptos主网上线，可以说这是Aptos区块链<strong>里程碑式的更新</strong>。</p><p>在官方介绍中，Aptos Keyless 允许用户使用他们现有的谷歌账户来设置 Aptos 区块链账户，而不是使用传统的密钥或助记词，也就是说在Aptos上，用户不必特意创建钱包去交易，同时借助Google账号可以实现不同设备之间的丝滑使用。</p><hr><h3 id="Aptos-Keyless工作原理"><a href="#Aptos-Keyless工作原理" class="headerlink" title="Aptos Keyless工作原理"></a>Aptos Keyless工作原理</h3><p>Aptos Keyless 允许dapp使用 OIDC 提供商(如谷歌）进行用户身份验证，并生成一个包含用户身份、dApp 身份和临时公钥的<code>JWT</code>。通过用户身份和 dApp 身份的哈希值生成区块链账户地址。</p><p>签名的 <code>JWT</code> 将区块链地址绑定到 <code>EPK</code>(临时公钥），并将交易签名权限委托给 <code>EPK</code>。用户可以使用与其区块链账户关联的<code> EPK</code> 对交易进行签名。如果用户丢失了 <code>ESK</code>（临时私钥），他们可以通过 OIDC 提供商重新登录来获取新的 <code>EPK</code>。</p><blockquote><p>OIDC 提供商指的是Open Connect 提供商，允许客户端应用程序（如网站、移动应用等）使用认证和授权服务来验证终端用户的身份，并获取访问资源的权限，常见的 OIDC 提供商包括 Google、Microsoft、Auth0、Okta 等，它们为开发者和组织提供了便捷的身份验证和授权服务，帮助应用程序实现安全的用户身份验证和资源访问控制。</p></blockquote><hr><p>用户隐私方面：1. 不会透露用户google的邮件地址  2.对身份提供商隐藏用户的区块链地址和交易历史</p><p>目前面临的挑战是如何保持用户隐私，因为公开<code> JWT</code> 可能会泄露用户身份，而公开<code> EPK</code> 可能会允许 OIDC 提供商跟踪用户在链上的交易。</p><p>通过以上种种，我们足以窥见其革新性，传统繁琐的密钥管理和有“门槛”的Web3进入方式都将在这里得到解决。</p><h2 id="Aptos的特性"><a href="#Aptos的特性" class="headerlink" title="Aptos的特性"></a>Aptos的特性</h2><p>Aptos 框架由 Aptos 区块链的核心库和配置组成，被定义为一个可定期升级的模块包，同时Aptos通过引入Block-STM并行执行引擎、Quorum Store内存池协议和集成Move语言等技术，实现了高性能、低gas、可升级的伟大成果。利用模块化设计的思路对项目进行部署，更进一步保证了项目的安全性和可操作性。</p><h2 id="Aptos-与-Sui-有什么区别？"><a href="#Aptos-与-Sui-有什么区别？" class="headerlink" title="Aptos 与 Sui 有什么区别？"></a>Aptos 与 Sui 有什么区别？</h2><p>Aptos和Sui总是同时出现，那Sui到底与Aptos有什么关系呢？</p><p><strong>来源方面</strong>：与Aptos 不同，Sui 不是 Diem 的派生版本，而是从头开始构建，充分利用固有的可扩展性和快速结算能力提供高吞吐量、低延迟和经济实惠的计算资源。</p><p><strong>编程语言方面</strong>：Sui在原有的Move语言上添加了一个面向对象的存储系统，用于跟踪地址和交易等所有内容，更加有利于提供可扩展性。</p><p><strong>技术架构方面</strong>：更不同的是Sui 在其执行层中采用了 Narwhal 和 Tusk 的共识技术来实现并行化。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过初步的了解，我们知道了Aptos的大致技术架构和展望，值得期待的是 Move语言是否会在未来获得更多的曝光量，而Aptos会不会迎来下一波牛市的崛起也让人拭目以待。</p><p>目前Aptos正在发力培育亚太和华语地区的开发生态，目不暇接的共学营和黑客松也在等待着爱好者和开发者的垂青，同时处于早期发展阶段的 Aptos 也会提供相当多的建设机会给真正的信仰者，一起”Move on Aptos”!</p><hr><p><a href="https://www.notion.so/buidlerdao/Aptos-Web3-fa04fe55b4364594ad0ee20e429cb3f6">Aptos官方白皮书（Notion在线阅读）</a><br>有关Sui与Aptos区别: <a href="https://foresightnews.pro/article/detail/38911">https://foresightnews.pro/article/detail/38911</a><br>有关Aptos Keyless: <a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDYwOTQwNw==&mid=2247485476&idx=1&sn=2acad9ada9173b15aa75d8d766d94a61&chksm=ce47ff5b0a0e64cf430937879db62428b98dfef3d1bc146b3d68a32150cfcee3f56284da42c2&scene=126&sessionid=1718803508#rd">https://mp.weixin.qq.com/s?__biz=Mzg4NDYwOTQwNw==&amp;mid=2247485476&amp;idx=1&amp;sn=2acad9ada9173b15aa75d8d766d94a61&amp;chksm=ce47ff5b0a0e64cf430937879db62428b98dfef3d1bc146b3d68a32150cfcee3f56284da42c2&amp;scene=126&amp;sessionid=1718803508#rd</a><br>我的信息源:<br>    -foresight news  <a href="https://foresightnews.pro/">https://foresightnews.pro/</a><br>    -Aptos官网  <a href="https://aptosfoundation.org/">https://aptosfoundation.org/</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 研报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中二小文章</title>
      <link href="/2024/06/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%B8%AD%E4%BA%8C%E5%B0%8F%E6%96%87%E7%AB%A0/"/>
      <url>/2024/06/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%B8%AD%E4%BA%8C%E5%B0%8F%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="有关-就业课题体会"><a href="#有关-就业课题体会" class="headerlink" title="有关 ()就业课题体会"></a><strong>有关 ()就业课题体会</strong></h1><p>作为一名大一的学生，在这次的课程中我比较感兴趣的是有关就业的课题。在本次课堂上老师向我们展示了当前的就业形势和一些就业数据，让我们了解到了就业的情况。</p><p>大环境下来说，就业形势似乎没有前几年那么严峻，各方面数据也在变好，例如重点就业人群和整体失业率就有所改善，但对作为学生的我来说，可能更加关心青年就业方面的问题。在查询过一些资料后，我发现我国16到25岁的青年失业率仍然在上升。面临着市场的饱和和众多“孔乙己”言论，我们似乎真的要去思考，应该如何做才能“对口就业”，如何将所学的知识真正地应用在岗位中。</p><p>首先就得说回选择专业这件事了，还记得当时在网上看到的特别有印象的一句话“选择专业就像是在泰坦尼克号上选择位置一样，早晚都会沉的，不如选择自己喜欢的”。或许这个话有点过激，但是如今来说各个行业的就业环境确实不算太好，生物专业变销售这类新闻屡见不鲜，这些问题是我们目前都在面对的。同样，有另一句话也让我特别有感触“如果无法改变环境，那就改变你自己”，我们作为学生能做的，似乎只有将学校的课程踏踏实实地“吃进去”，只有学通了，才有资格将就业的部分责任推到这个环境中去。</p><p>因为不仅仅是我们选择了专业，专业同时也选择了我们。就拿区块链来说，可能不了解的人仅仅会觉得这是庞氏骗局，是泡沫经济，但是我们作为它的研究者和学习者，甚至是开拓者。我们不能在我们还没有了解清楚的情况下，丧失掉对行业的信心和对未来的信心。对我来说，大学是完全新的一个阶段，抓紧时间去追求自己想要的，去实现自己的价值是一件很重要的事。</p><p>无关就业严峻与否，尽力做好自己应该做的事，问心无愧再问天地。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>扫盲小知识之 质押与再质押</title>
      <link href="/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/2024-05-21-%E6%89%AB%E7%9B%B2%E5%B0%8F%E7%9F%A5%E8%AF%86%E4%B9%8B-%E8%B4%A8%E6%8A%BC%E4%B8%8E%E5%86%8D%E8%B4%A8%E6%8A%BC/"/>
      <url>/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/2024-05-21-%E6%89%AB%E7%9B%B2%E5%B0%8F%E7%9F%A5%E8%AF%86%E4%B9%8B-%E8%B4%A8%E6%8A%BC%E4%B8%8E%E5%86%8D%E8%B4%A8%E6%8A%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="质押-staking-与-再质押-restaking"><a href="#质押-staking-与-再质押-restaking" class="headerlink" title="质押(staking) 与 再质押(restaking)"></a>质押(staking) 与 再质押(restaking)</h1><h2 id="质押"><a href="#质押" class="headerlink" title="质押"></a>质押</h2><blockquote><p>质押（staking）是一种通过锁定一定数量的加密货币来支持区块链网络操作（例如验证交易和维护网络安全）的机制。作为回报，质押者可以获得奖励（通常是额外的加密货币），同时质押者通常拥有一定的投票权或参与网络治理的权利</p></blockquote><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a><strong>详细解释</strong>：</h3><ul><li><strong>Proof of Stake（PoS）</strong>：质押最常见于基于权益证明（Proof of Stake, PoS）共识机制的区块链中。在这种机制下，区块链通过质押者的投票选举出区块验证者（validators），而不是通过解决复杂的数学难题（如在工作量证明（Proof of Work, PoW）机制中）。</li><li><strong>奖励</strong>：质押者通常会根据他们所质押的加密货币数量和质押时间长度来获得奖励。这些奖励可以是新生成的加密货币或交易费用的一部分。</li><li><strong>风险</strong>：质押也有风险，例如质押的加密货币可能会被冻结一定时间，无法随时取出。此外，如果网络遭受攻击或质押者不遵守规则，可能会损失一部分或全部质押的加密货币。</li></ul><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例</strong>：</h3><ul><li><strong>以太坊2.0</strong>：以太坊2.0采用PoS机制，用户可以质押32个以太币（ETH）成为验证者，并获得奖励。</li></ul><h3 id="为什么ETH会存在质押的模式"><a href="#为什么ETH会存在质押的模式" class="headerlink" title="为什么ETH会存在质押的模式?"></a>为什么ETH会存在质押的模式?</h3><p>质押是权益证明（Proof of Stake, PoS）及其变种共识机制的核心概念.下面是我在网络上看到的有关文章的部分节选,完整版请参照</p><blockquote><p>[<strong>白话区块链</strong>]    <a href="https://www.hellobtc.com/kp/du/09/4703.html">https://www.hellobtc.com/kp/du/09/4703.html</a> 质押现状：以太坊合并一年后的 5 大看点</p><p>ps: 我觉得这个频道用来扫盲挺好的,不过不要仅仅局限于一篇文章</p></blockquote><img src="file://C:/Users/32423/AppData/Roaming/Typora/typora-user-images/image-20240605184045270.png?lastModify=1717592035?lastModify=1717592086" alt="image-20240605184045270" style="zoom:25%;" /><h2 id="再质押"><a href="#再质押" class="headerlink" title="再质押"></a>再质押</h2><blockquote><p>「再质押」是一个将流动性质押代币资产用于在其他区块链的验证者进行质押，以获得更多收益，同时有助于提高新网络的安全性和去中心化的行为。也可理解为再质押是加密经济安全中的一个新概念，它使以太坊既定的经济信任能够扩展到保护其他分布式系统，例如预言机、桥接器或侧链。      其使用从质押获得的奖励继续向该节点存款，以增加未来的利润。通过再质押，投资者可以从原始协议和再质押协议两方面获得多重收益。</p></blockquote><h3 id="再质押的实现方式"><a href="#再质押的实现方式" class="headerlink" title="再质押的实现方式"></a>再质押的实现方式</h3><p><strong>再质押主要是基于以太坊的安全框架来提升整个加密货币生态系统中的资金使用效率；质押者在能够支持一个网络安全性的同时还能够为多个网络提供验证服务，从而获得额外的奖励。</strong></p><ol><li><strong>衍生代币（Derivative Tokens）</strong>：<ul><li>当用户在某个平台上质押其资产后，平台可以为用户生成一种代表这些质押资产的衍生代币。</li><li>例如，用户在平台A上质押ETH，平台A会给用户发放一种代币，如stETH，代表用户在平台A上质押的ETH。</li><li>用户可以拿这些衍生代币（如stETH）去另一个平台B上进行再质押或参与其他DeFi活动。</li></ul></li><li><strong>合约层的再质押</strong>：<ul><li>一些区块链协议或智能合约平台允许直接将已经质押的资产再质押。</li><li>例如，通过跨链桥或跨协议的智能合约，用户可以将质押的资产从一个网络转移并质押到另一个网络。</li></ul></li><li><strong>流动性质押（Liquid Staking）</strong>：<ul><li>这种方式允许用户在质押其资产的同时，获取一种具有流动性的代币，这种代币可以在其他平台上进行交易或再质押。</li><li>流动性质押代币通常可以在市场上自由交易，使用户即使在质押期间，也能有一定的流动性来参与其他投资活动。</li></ul></li></ol><h3 id="再质押的风险"><a href="#再质押的风险" class="headerlink" title="再质押的风险"></a>再质押的风险</h3><ol><li><p><strong>智能合约风险</strong>：</p><ul><li>再质押涉及多个智能合约，每个智能合约都有可能存在漏洞或被攻击的风险。</li></ul></li><li><p><strong>流动性风险</strong>：</p><ul><li>衍生代币或流动性质押代币的市场流动性可能不足，导致在需要变现时价格波动较大。</li></ul></li><li><p><strong>复杂性风险</strong>：</p><ul><li>再质押增加了操作的复杂性，用户需要了解和管理多个平台和代币，可能会遇到操作失误或平台不兼容的问题。</li></ul></li></ol><h3 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h3><h4 id="1-提高收益率"><a href="#1-提高收益率" class="headerlink" title="1. 提高收益率"></a>1. <strong>提高收益率</strong></h4><h5 id="流动性质押（Liquid-Staking）"><a href="#流动性质押（Liquid-Staking）" class="headerlink" title="流动性质押（Liquid Staking）"></a>流动性质押（Liquid Staking）</h5><ul><li><strong>场景</strong>：用户质押ETH在Lido上，获得stETH。</li><li><strong>运用</strong>：用户可以将stETH再质押在其他DeFi协议中，如Aave或Compound，获取借贷利息或参与流动性挖矿，进一步提高收益率。</li></ul><h5 id="跨平台收益最大化"><a href="#跨平台收益最大化" class="headerlink" title="跨平台收益最大化"></a>跨平台收益最大化</h5><ul><li><strong>场景</strong>：用户质押资产在某个平台上获得收益，但发现另一个平台提供更高的收益率。</li><li><strong>运用</strong>：用户将质押资产转化为衍生代币后，转移到收益更高的平台进行再质押。</li></ul><h4 id="2-流动性增强"><a href="#2-流动性增强" class="headerlink" title="2. 流动性增强"></a>2. <strong>流动性增强</strong></h4><h5 id="跨链流动性提供"><a href="#跨链流动性提供" class="headerlink" title="跨链流动性提供"></a>跨链流动性提供</h5><ul><li><strong>场景</strong>：用户在以太坊上质押ETH，获得衍生代币。</li><li><strong>运用</strong>：用户将衍生代币通过跨链桥转移到其他区块链（如Polkadot或Binance Smart Chain），并在这些链上参与流动性池或借贷平台，提供流动性。</li></ul><h5 id="去中心化交易所（DEX）流动性挖矿"><a href="#去中心化交易所（DEX）流动性挖矿" class="headerlink" title="去中心化交易所（DEX）流动性挖矿"></a>去中心化交易所（DEX）流动性挖矿</h5><ul><li><strong>场景</strong>：用户质押资产获得流动性质押代币。</li><li><strong>运用</strong>：用户将这些流动性质押代币提供给去中心化交易所的流动性池，获得流动性挖矿奖励，同时保持资产流动性。</li></ul><h4 id="3-多重收益"><a href="#3-多重收益" class="headerlink" title="3. 多重收益"></a>3. <strong>多重收益</strong></h4><h5 id="合成资产生成"><a href="#合成资产生成" class="headerlink" title="合成资产生成"></a>合成资产生成</h5><ul><li><strong>场景</strong>：用户在某平台质押资产，获得衍生代币。</li><li><strong>运用</strong>：用户使用这些衍生代币在合成资产平台（如Synthetix）上生成合成资产（如sUSD或sBTC），再将合成资产用于交易或借贷，获得多重收益。</li></ul><h5 id="DeFi生态系统参与"><a href="#DeFi生态系统参与" class="headerlink" title="DeFi生态系统参与"></a>DeFi生态系统参与</h5><ul><li><p><strong>场景</strong>：用户质押ETH在Lido上，获得stETH。</p></li><li><p><strong>运用</strong>：用户使用stETH在Curve、Yearn等平台参与流动性挖矿、收益聚合等活动，获得平台奖励和交易费。</p></li></ul><h4 id="4-风险对冲"><a href="#4-风险对冲" class="headerlink" title="4. 风险对冲"></a>4. <strong>风险对冲</strong></h4><h5 id="衍生品交易"><a href="#衍生品交易" class="headerlink" title="衍生品交易"></a>衍生品交易</h5><ul><li><strong>场景</strong>：用户质押资产获得流动性质押代币。</li><li><strong>运用</strong>：用户使用这些代币在衍生品平台（如dYdX或Perpetual Protocol）进行杠杆交易或期权交易，对冲价格波动风险。</li></ul><h5 id="稳定币生成"><a href="#稳定币生成" class="headerlink" title="稳定币生成"></a>稳定币生成</h5><ul><li><p><strong>场景</strong>：用户质押ETH获得stETH。</p></li><li><p><strong>运用</strong>：用户在MakerDAO等稳定币生成平台上将stETH作为抵押品，生成DAI等稳定币，用于其他DeFi操作或风险对冲。</p></li></ul><h4 id="5-去中心化自治组织（DAO）治理"><a href="#5-去中心化自治组织（DAO）治理" class="headerlink" title="5. 去中心化自治组织（DAO）治理"></a>5. <strong>去中心化自治组织（DAO）治理</strong></h4><h5 id="提高投票权重"><a href="#提高投票权重" class="headerlink" title="提高投票权重"></a>提高投票权重</h5><ul><li><strong>场景</strong>：用户质押资产获得治理代币。</li><li><strong>运用</strong>：用户将治理代币再质押在治理平台上，提高在去中心化自治组织中的投票权重，影响平台决策。</li></ul><h5 id="提案创建和支持"><a href="#提案创建和支持" class="headerlink" title="提案创建和支持"></a>提案创建和支持</h5><ul><li><strong>场景</strong>：用户质押资产参与某DAO获得治理代币。</li><li><strong>运用</strong>：用户将治理代币再质押以创建或支持新的提案，提高提案通过的几率，积极参与治理。</li></ul><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>通俗来说流动性质押代币（<strong>LST</strong>）代表质押 ETH 和累积奖励的代币化版本，流动性再质押代币（<strong>LRT</strong>）代表再质押 ETH 和累积奖励的代币化版本。相关项目 我之前整理过一篇  <a href="https://404ll.github.io/2024/05/10/AVS%E4%BB%A5%E5%8F%8AEigenLayer%E8%A7%A3%E6%9E%90/">Eigenlayer</a>的文章，有兴趣可以看看</p><p>具体深入了解,可以参考这篇(文章中还涉及了 质押与再质押的原理区别)</p><p> 📌<a href="https://foresightnews.pro/article/detail/55642">一文读懂「再质押 Restaking 」赛道</a></p><h2 id="比较好的信息网站"><a href="#比较好的信息网站" class="headerlink" title="比较好的信息网站"></a>比较好的信息网站</h2><p>📌<a href="https://foresightnews.pro/">foresight news</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫盲小知识之 Roll-up</title>
      <link href="/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/Roll-up/"/>
      <url>/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/Roll-up/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Roll-up"><a href="#什么是-Roll-up" class="headerlink" title="什么是 Roll-up ?"></a>什么是 Roll-up ?</h1><blockquote><p>Roll-up是一种Layer 2扩展解决方案，旨在提高以太坊网络的吞吐量和效率。<strong>它通过将大量的交易数据压缩成少量的摘要信息，然后将这些摘要信息提交到以太坊主链上，以实现高性能的链上交易处理。</strong></p><p><strong>人话就是</strong> :  把以太坊上几百笔交易打包带走，并在验证通过后只向以太坊主网输出一笔交易。</p></blockquote><p> 具体可以看看这篇文章：<a href="https://foresightnews.pro/article/h5Detail/59078">https://foresightnews.pro/article/h5Detail/59078</a></p><p>Roll-up通常分为这几种类型：</p><ol><li><p><strong>Optimistic Roll-up（乐观 Roll-up）</strong>:  默认打包的这些交易每一笔都是准确无误的，因此会直接进入验证。但为了防止错误交易混入其中，乐观证明引入了挑战者机制，就是说在验证的一定期限内，其他人可以怀疑其中的交易并在以太坊上比对这笔交易是否合法。如果挑战成功，挑战者就可以获得收益，验证者就会被罚没质押在协议上的资金。</p></li><li><p><strong>ZK-Rollup（零知识 Roll-up）</strong></p><p>​     在ZK-Rollup中，交易的验证过程使用了零知识证明技术，可以在不暴露具体交易内容的情况下证明交易的有效性。这样可以进一步减少在主链上的数据量，并提高隐私性和效率.</p></li></ol><p>Roll-up技术的引入为以太坊网络提供了一种高效的扩展方案，可以大幅提升网络的吞吐量和性能，同时降低交易成本，并为更多的去中心化应用提供了支持。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫盲小知识之 L1 L2</title>
      <link href="/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%80%E4%B9%88%E6%98%AFLayer1-Layer2/"/>
      <url>/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%80%E4%B9%88%E6%98%AFLayer1-Layer2/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Layer1-Layer2"><a href="#什么是-Layer1-Layer2" class="headerlink" title="什么是 Layer1  Layer2?"></a>什么是 Layer1  Layer2?</h1><p>Layer1是区块链的基础层，负责确认和记录交易；Layer2是用于扩容的解决方案，负责处理和记录高吞吐量的交易。</p><h2 id="什么是-Layer1"><a href="#什么是-Layer1" class="headerlink" title="什么是 Layer1?"></a>什么是 Layer1?</h2><p>第一层就是传统意义上的区块链，包括：比特币，以太坊，Aptos等</p><p>Layer1是区块链技术中的一个术语，指的是区块链协议中的基础层。它是指构成区块链网络基础架构的核心协议和数据结构，通常是一种完整的、独立的区块链网络，具有自己的共识机制和数据存储方式。Layer1协议负责处理交易验证、区块生成和链上数据存储等核心功能。</p><p>在Layer1层面，通常会涉及到底层的区块链技术和算法设计，如工作量证明（Proof of Work）或权益证明（Proof of Stake）等共识机制，以及区块链的数据结构、加密算法等。Layer1协议的设计决定了整个区块链网络的性能、安全性和去中心化程度。</p><h2 id="什么是-Layer2"><a href="#什么是-Layer2" class="headerlink" title="什么是 Layer2?"></a>什么是 Layer2?</h2><blockquote><p>本文只提供粗浅的定义，若想进一步了解，可以看看<a href="https://blog.chain.link/what-is-a-layer-2-zh/">一文读懂第 2 层</a> 🌟</p></blockquote><p>Layer 2的目的是通过在区块链之上引入额外的协议或机制，提供更高的吞吐量、低延迟和更便宜的交易，并解决Layer 1网络可能存在的扩展性和性能问题。</p><p>Layer 2解决方案通常可以分为两种主要类型：</p><ol><li><strong>状态通道（State Channels）</strong>：状态通道是一种通过在链外执行交易并最终将交易结果提交到区块链上的解决方案。在状态通道中，参与者可以直接在彼此之间进行多次交易，而不必在每次交易都提交到区块链上进行确认，从而大大提高了交易的速度和吞吐量。</li><li><strong>侧链（Sidechains）</strong>：侧链是与主区块链相互连接的独立区块链，可以处理与主链不同的交易逻辑和数据。通过侧链，用户可以将资产从主链转移到侧链上进行高速和低成本的交易，然后再将结果汇总提交到主链上，从而减轻了主链的负担，提高了整个系统的性能。</li></ol><p>有关扩容方案的文章 </p><p>[]: <a href="https://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&amp;mid=2247500009&amp;idx=2&amp;sn=aa68710cd3eb1758dff8776bbc1be70e&amp;chksm=fa01f7cecd767ed86a724a284233cca3cc0aec84d0a99ef126392305dd20f5c99976d37e6d27#rd">https://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&amp;mid=2247500009&amp;idx=2&amp;sn=aa68710cd3eb1758dff8776bbc1be70e&amp;chksm=fa01f7cecd767ed86a724a284233cca3cc0aec84d0a99ef126392305dd20f5c99976d37e6d27#rd</a>“一文看懂区块链的扩容方案和主要的二层网络（Layer 2）方案”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVS以及EigenLayer解析</title>
      <link href="/2024/05/10/%E5%8C%BA%E5%9D%97%E9%93%BE/AVS%E4%BB%A5%E5%8F%8AEigenLayer%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/05/10/%E5%8C%BA%E5%9D%97%E9%93%BE/AVS%E4%BB%A5%E5%8F%8AEigenLayer%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）"><a href="#一、-AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）" class="headerlink" title="一、 AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）"></a><strong>一、 AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）</strong></h2><p>AVS全称主动验证服务，其龙头是EigenLayer，在直播当天（北京时间2024年4月30日）刚刚公布了自己的代币计划。</p><h3 id="1-AVS赛道的逻辑及其底层原因"><a href="#1-AVS赛道的逻辑及其底层原因" class="headerlink" title="1. AVS赛道的逻辑及其底层原因:"></a>1. AVS赛道的逻辑及其底层原因:</h3><p>共识在区块链中至关重要，以太坊节点提供的服务在过去仅仅包括交易排序交易执行，但是其他服务来自于其他的服务商（跨链桥、预言机等等），其他的服务商资产量不够，所以很容易被攻击，最终导致了DApp的用户遭受损失。</p><p>AVS赛道的逻辑是通过将区块链本身的安全性桥接到主动验证服务商身上，利用以太坊的高级安全性来赋能这些服务商，从而将以太坊的安全性扩展到这些中间件身上。这样做的底层原因是为了弥补区块链中共识机制下的短板，使其得到补足。</p><h3 id="2-Eigenlayer代币经济学"><a href="#2-Eigenlayer代币经济学" class="headerlink" title="2. Eigenlayer代币经济学"></a><strong>2. Eigenlayer代币经济学</strong></h3><p>从分配的角度来看，超过一半（55%）的代币分配给了EigenLayer团队和投资者，而余下的分配给了社区；从应用的角度来看，EigenLayer代币的使用涉及到与DeFi协议的交互，其中可能包括借贷、交易和提供流动性等操作。但是代币分配给了少数人，这可能导致代币解锁后的抛售压力增加。</p><p><strong>空投</strong>：将再质押的代币九成给到平台交互用户，一成给到defi协议的用户，但是中国、美国的用户被限制。</p><p><strong>代币的价值</strong>：基于流通量和市值来推断，可能会有一定的不确定性。保守估计18元，目前场外9-12元</p><p><strong>Puffer是否被限制在10%：</strong>实际是一个误解。只是大户直接存入的量更大，导致他们挖得的积分比较多，从而分配到的空投也比较多。Puffer实际上并没有设定一个10%的限制，而是根据积分的累积来分配代币，大概只有10%来自于Defi那些东西。</p><h2 id="二．EigenLayer的锁仓逻辑"><a href="#二．EigenLayer的锁仓逻辑" class="headerlink" title="二．EigenLayer的锁仓逻辑"></a>二．<strong>EigenLayer的锁仓逻辑</strong></h2><p>EigenLayer的代币锁仓逻辑通过不可转移的代币和可质押的机制，建立稳定的社区基础，避免短期波动，以支持项目的长期发展。</p><ol><li><p>代币不可转移：在锁仓期间，代币持有者无法将其代币转移到其他地址或进行交易。避免短期内的代币大规模流通，从而稳定价格和社区生态。</p></li><li><p>质押机制：代币持有者可以选择将代币质押，尽管代币不可转移，但质押允许持有者保留代币的所有权，并获得相应的回报或权益。</p></li></ol><h2 id="三．为什么Eigenlayer-这么受关注？"><a href="#三．为什么Eigenlayer-这么受关注？" class="headerlink" title="三．为什么Eigenlayer 这么受关注？"></a><strong>三．为什么Eigenlayer 这么受关注？</strong></h2><ol><li><p>独特地位：作为AVS和Restaking项目的龙头，EigenLayer在DeFi领域占据了独特的地位</p></li><li><p>提供安全性保障：EigenLayer允许用户质押资产，为其他DeFi协议提供安全性保障</p></li><li><p>高度锁仓的代币设计：EigenLayer采取了措施确保代币的稳定性和可持续性，这对项目的长期发展产生积极影响。</p></li></ol><p><strong>五．AVS与模块化区块链有什么关联？</strong></p><p>AVS与模块化区块链都是为了提高区块链网络的效率和安全性而采取的一种方法。</p><p><strong>模块化区块链</strong>：将区块链网络的不同功能模块分离开来，使得每个模块可以独立运行，相互之间不产生影响。提高系统的可扩展性和灵活性，同时降低了开发和维护的难度。</p><p><strong>AVS</strong>：由于零知识证明的验证成本比较高，通过质押的方式提高节点执行作恶的成本，让应用更加安全，同时加快验证交易的速度。质押的代币可以被用来执行网络中的任务，并作为一种激励来防止恶意行为。提高区块链网络的安全性，同时也为参与者提供了一种获利的机会。</p><h2 id="四．EigenLayer和Restaking有什么比较好的方向？"><a href="#四．EigenLayer和Restaking有什么比较好的方向？" class="headerlink" title="四．EigenLayer和Restaking有什么比较好的方向？"></a><strong>四．EigenLayer和Restaking有什么比较好的方向？</strong></h2><ol><li><p>提供更有效率的解决方案：在市场上已有的服务效率较低的情况下，可以提供更有效率的解决方案。例如，结合密码学安全性和Restaking技术，对交易进行分类处理：采用零知识证明（zk）验证重要交易，采用Restaking验证一般性交易。这种方法可以让大量zk项目运作起来，提高整体效率。</p></li><li><p>与融资充足的项目合作：与已经融资充足且有潜力的项目合作，利用它们的业务机会。特别是在技术尚未成熟但市场机会已经出现的情况下，与这些项目合作，提供简单或者价值较低的交易验证服务，从而抓住市场机会。</p></li></ol><h2 id="五．Eigenlayer150-亿美金的锁仓量是否已经超过了-AvS-安全性的实际需求"><a href="#五．Eigenlayer150-亿美金的锁仓量是否已经超过了-AvS-安全性的实际需求" class="headerlink" title="五．Eigenlayer150 亿美金的锁仓量是否已经超过了 AvS 安全性的实际需求?"></a><strong>五．Eigenlayer150 亿美金的锁仓量是否已经超过了 AvS 安全性的实际需求?</strong></h2><p>这种情况可能是一个动态平衡。在项目初期，可能会有大量锁仓，主要是因为一些人想要获取更多的积分，而另一些人则想要做空。这导致了锁仓量的虚高。随着时间的推移，项目会发展壮大，空投活动逐渐减少，资金也会流向其他地方。因此，锁仓量可能会减少并达到一个动态平衡点。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="六．EigenLayer-为什么不选Solana而选择以太坊？"><a href="#六．EigenLayer-为什么不选Solana而选择以太坊？" class="headerlink" title="六．EigenLayer 为什么不选Solana而选择以太坊？"></a>六．EigenLayer <strong>为什么不选Solana而选择以太坊？</strong></h2><p>以太坊具有较长的共识历史，其安全性更高。同时以太坊网络上已经存在着大量的节点和质押资产，形成了一个相对稳定和安全的生态系统，这对于项目的发展和用户的信任至关重要。相比之下Solana的不确定性更大，安全性更低，流动性更差，Defi生态不太强</p><h2 id="七．ETH的EigenLayer和BTC的Babylon的区别是什么？"><a href="#七．ETH的EigenLayer和BTC的Babylon的区别是什么？" class="headerlink" title="七．ETH的EigenLayer和BTC的Babylon的区别是什么？"></a>七．ETH的EigenLayer和BTC的Babylon的区别是什么？</h2><p>EigenLayer和Babylon在解决的问题和定位上存在一些不同</p><p>Babylon致力于解决比特币的闲置和无法获得利息的问题。它通过一种名为”remo-staking”的操作，使得持有比特币的用户能够在不离开比特币网络的情况下参与质押，从而获得一定的收益。</p><p>EigenLayer更加关注以太坊网络上已经质押了资产的用户，为他们提供一个在不需要牺牲安全性的前提下，可以为其他中间层提供质押服务的机会，EigenLayer致力于解决以太坊网络中质押者的机会成本问题，以及降低中间层支付高昂资金成本的问题，从而提高质押网络的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Uweb笔记整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML表单</title>
      <link href="/2024/04/25/%E5%89%8D%E7%AB%AF/HTML%E8%A1%A8%E5%8D%95/"/>
      <url>/2024/04/25/%E5%89%8D%E7%AB%AF/HTML%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>表单（Form）是 HTML 中用于收集用户输入信息并将其提交到服务器的一种机制。它通常由包含表单元素的一组 HTML 元素组成，用户可以在表单中输入数据并通过提交按钮将数据发送到服务器进行处理&#x3D;&gt;</p><p>我的理解: 就是C语言中的scanf()和getchar(),用来读取用户的输入 </p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><code>&lt;form&gt;</code> 元素用于创建表单，<code>action</code> 属性定义了表单数据提交的目标 URL，<code>method</code> 属性定义了提交数据的 HTTP 方法（这里使用的是 “post”）</p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p><code>method</code> 属性用于定义 HTML 表单提交数据时所使用的 HTTP 方法。在 Web 开发中，常见的 HTTP 方法有两种：GET 和 POST。</p><ol><li><strong>GET 方法</strong>：</li></ol><ul><li>当使用 GET 方法提交表单时，表单数据会附加在 URL 的末尾，并作为查询字符串的一部分发送到服务器。</li><li>GET 方法通常用于请求资源，比如请求页面、提交搜索查询等。</li><li>使用 GET 方法提交的表单数据会在 URL 中可见，因此不适合传输敏感信息，且有长度限制。</li></ul><ol start="2"><li><strong>POST 方法</strong>：</li></ol><ul><li>当使用 POST 方法提交表单时，表单数据会作为 HTTP 请求的正文发送到服务器。</li><li>POST 方法通常用于向服务器提交较大量或敏感信息的数据，比如用户注册信息、登录凭证等。</li><li>使用 POST 方法提交的表单数据不会在 URL 中可见，因此更安全，并且没有长度限制。</li></ul><p>在 HTML 表单中，通过设置 <code>method</code> 属性为 “post”，表示表单数据将使用 POST 方法提交给服务器。这意味着用户填写的数据会作为 HTTP 请求的正文发送到服务器，而不会出现在 URL 中，从而保护了用户数据的隐私和安全性。</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>表单的动作属性 <strong>action</strong> 定义了服务端的文件名。</p><p><strong>action</strong> 属性会对接收到的用户输入数据进行相关的处理</p><p>例如 action&#x3D;”html_form_action.php”，输入数据会传送到 <strong>html_form_action.php</strong> 文件，该页面将显示出输入的结果。</p><h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h3><p>文本域通过<code> &lt;input type=&quot;text&quot;&gt;</code>标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域</p><h2 id="代码罗列"><a href="#代码罗列" class="headerlink" title="代码罗列"></a>代码罗列</h2><p><code>required</code>表示必填</p><p><code>label</code> 为了增强可读性</p><p><code>checked</code> 表示默认选中&#x3D;&gt;进入就能看到的</p><p><code>value</code> 属性指定了用户输入的默认值或者在提交表单时发送到服务器的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表单<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 密码输入框 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 单选按钮 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 复选框  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 下拉列表 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span>国家:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>CN<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;uk&quot;</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>删去lable版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入密码&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript学习随笔</title>
      <link href="/2024/04/25/%E5%89%8D%E7%AB%AF/JavaScript%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/"/>
      <url>/2024/04/25/%E5%89%8D%E7%AB%AF/JavaScript%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript-学习随笔"><a href="#Javascript-学习随笔" class="headerlink" title="Javascript 学习随笔"></a>Javascript 学习随笔</h1><blockquote><p>学习网站是：<a href="https://www.runoob.com/">https://www.runoob.com/</a><br>因为在这之前我只系统学习了C,因此在学习Javascript的过程中主要采用了比较的方法.</p></blockquote><h2 id="代码小问题"><a href="#代码小问题" class="headerlink" title="代码小问题"></a>代码小问题</h2><h3 id="为什么使用“-”？"><a href="#为什么使用“-”？" class="headerlink" title="为什么使用“+”？"></a>为什么使用“+”？</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> =<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> &#123;&#125; + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> [] + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>;<br></code></pre></td></tr></table></figure><p>在 JavaScript 中，<code>+</code> 运算符用于连接字符串。在这段代码中，<code>&quot;&lt;br&gt;&quot;</code> 是一个字符串，通过使用 <code>+</code> 运算符，我们将各种数据类型的类型输出连接成一个长字符串，然后将这个字符串设置为 <code>&lt;p&gt;</code> 元素的 <code>innerHTML</code>。这样可以确保每种数据类型的类型都输出到段落中，而不会覆盖之前的输出。</p><p>如果我们不使用 <code>+</code> 运算符，而是使用多个 <code>document.getElementById(&quot;demo&quot;).innerHTML</code> 进行赋值，只有最后一个赋值会生效，因为每次赋值都会覆盖之前的内容。通过使用 <code>+</code> 运算符，我们将每种类型的类型连接成一个字符串，然后一次性将整个字符串赋值给 <code>&lt;p&gt;</code> 元素的 <code>innerHTML</code>，这样就可以将所有类型都输出到段落中</p><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个空数组</span><br><span class="hljs-keyword">let</span> emptyArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br><br><span class="hljs-comment">// 创建指定长度的空数组</span><br><span class="hljs-keyword">let</span> arrayWithLength = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 创建包含元素的数组</span><br><span class="hljs-keyword">let</span> fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>);<br><span class="hljs-comment">//直接</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript 中的对象是一种复合数据类型，用于存储多个<strong>键值对</strong> <em>在这里被称为<strong>对象属性</strong></em>。对象可以包含各种类型的数据，包括其他对象、数组、函数等</p><blockquote><p>关于键值对：我简单理解为名字和值一一对应的一种数据结构</p></blockquote><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>就是属性值为函数</p><p><strong>特殊属性和方法</strong>：</p><ul><li><p><strong>原型（Prototype）</strong>：每个对象都有一个原型，它是一个指向另一个对象的引用，可以用于实现继承。</p></li><li><p><strong>构造函数（Constructor）</strong>：用于创建对象的函数。</p></li><li><p><strong>内置属性和方法</strong>：例如 <code>toString()</code>、<code>valueOf()</code> 等，这些方法和属性是 JavaScript 内置对象的一部分，可以直接使用</p></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>因为C中没有这个概念，所以这里着重写一下</p><blockquote><p>在 JavaScript 中，事件是指在 HTML 文档中发生的某些事情或动作，比如用户的交互操作（例如点击、鼠标移动、键盘输入等）或者浏览器自身的操作（例如页面加载完成、窗口大小改变等）。</p><p>HTML文档:我单纯理解为这个页面中包含的所有东西</p></blockquote><p><strong>事件可以分为两类：内置事件和用户自定义事件。</strong></p><ol><li><h3 id="内置事件："><a href="#内置事件：" class="headerlink" title="内置事件："></a><strong>内置事件</strong>：</h3><ul><li><p>内置事件是浏览器或者特定 HTML 元素自身触发的事件，比如：</p><ul><li><p>页面加载完成事件 (<code>load</code>)</p></li><li><p>鼠标点击事件 (<code>click</code>)</p></li><li><p>鼠标移动事件 (<code>mousemove</code>)</p></li><li><p>键盘按键事件 (<code>keydown</code>, <code>keyup</code>, <code>keypress</code>)</p></li><li><p>表单提交事件 (<code>submit</code>)</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Event Examples&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;!-- Click Event Example --&gt;<br>&lt;button onclick=&quot;alert(&#x27;按钮被点击了！&#x27;)&quot;&gt;点击我&lt;/button&gt;<br><br>&lt;hr&gt;<br><br>&lt;!-- Mousemove Event Example --&gt;<br>&lt;div style=&quot;width: 100px; height: 100px; background-color: red;&quot; onmousemove=&quot;alert(&#x27;鼠标移动到了盒子上！&#x27;)&quot;&gt;&lt;/div&gt;<br><br>&lt;hr&gt;<br><br>&lt;!-- Key Event Example --&gt;<br>&lt;input type=&quot;text&quot; <br>       placeholder=&quot;按下按键或者松开按键&quot; <br>       onkeydown=&quot;alert(&#x27;按键按下了！&#x27;)&quot; <br>       onkeyup=&quot;alert(&#x27;按键松开了！&#x27;)&quot; <br>       onkeypress=&quot;alert(&#x27;按键被按下并松开了！&#x27;)&quot;&gt;<br><br>&lt;hr&gt;<br><br>&lt;!-- Load Event Example --&gt;<br>&lt;script&gt;<br>    function pageLoaded() &#123;<br>        alert(&#x27;页面加载完成！&#x27;);<br>    &#125;<br>    window.onload = pageLoaded;<br>&lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><h3 id="用户自定义事件："><a href="#用户自定义事件：" class="headerlink" title="用户自定义事件："></a><strong>用户自定义事件</strong>：</h3><ul><li>除了内置事件之外，开发者还可以自定义事件，以便在特定情况下触发 JavaScript 代码执行。这种自定义事件通常是通过 <code>Event</code> 对象的构造函数来创建，并且可以通过 <code>dispatchEvent()</code> 方法手动触发。</li></ul></li></ol><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p><code>===</code>:绝对相等&#x3D;&gt;值类型都相等</p><p><code>!==</code>:不绝对相等</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>大体相同,还有一种比较特别的for循环</p><p><code>itCompanies</code> 是一个数组，<code>for...of</code> 循环用来遍历数组中的元素。<code>company</code> 是循环中的一个临时变量，每次迭代时，它会被赋值为数组中的一个元素。所以你的解释几乎正确，但是应该是将 <code>company</code> 赋值为 <code>itCompanies</code> 数组中的每个元素，而不是整个数组本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> itCompanies = [<span class="hljs-string">&quot;Facebook&quot;</span>, <span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Microsoft&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;IBM&quot;</span>, <span class="hljs-string">&quot;Oracle&quot;</span>, <span class="hljs-string">&quot;Amazon&quot;</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> company <span class="hljs-keyword">of</span> itCompanies) &#123;<span class="hljs-comment">//让company赋值为itCompanies中的一个元素</span><br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> company) &#123;<br>    <span class="hljs-keyword">if</span> (char.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&quot;o&quot;</span>) &#123;<br>      count++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>    companiesWithMoreThanOneO.<span class="hljs-title function_">push</span>(company);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Companies with more than one &#x27;o&#x27;:&quot;</span>, companiesWithMoreThanOneO);<br></code></pre></td></tr></table></figure><h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p><h2 id="Data-方法"><a href="#Data-方法" class="headerlink" title="Data()方法"></a>Data()方法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getDate()</td><td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td align="left">getDay()</td><td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td align="left">getFullYear()</td><td align="left">从 Date 对象以四位数字返回年份。</td></tr><tr><td align="left">getHours()</td><td align="left">返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="left">getMilliseconds()</td><td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="left">getMinutes()</td><td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="left">getMonth()</td><td align="left">从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="left">getSeconds()</td><td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td align="left">getTime()</td><td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td></tr></tbody></table><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>&#x2F;正则表达式主体&#x2F;修饰符(可选)</p><h3 id="使用字符串方法"><a href="#使用字符串方法" class="headerlink" title="使用字符串方法"></a>使用字符串方法</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p><p><strong>search()</strong> 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p><p><strong>replace()</strong> 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</p><p><strong>exec()</strong> 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p><h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><p><strong>修饰符</strong> 可以在全局搜索中不区分大小写:</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">执行对大小写不敏感的匹配。</td></tr><tr><td align="left">g</td><td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="left">m</td><td align="left">执行多行匹配。</td></tr></tbody></table><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h4 id="try-catch-throw"><a href="#try-catch-throw" class="headerlink" title="try  catch  throw"></a><strong>try  catch  throw</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> message, x;<br>  message = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p01&quot;</span>);<br>  message.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  x = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">value</span>;<br>  <span class="hljs-keyword">try</span> &#123; <br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;值是空的&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isNaN</span>(x)) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;值不是一个数字&quot;</span>;<br>    x = <span class="hljs-title class_">Number</span>(x);<br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;太大&quot;</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">5</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;太小&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(err) &#123;<br>    message.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;错误: &quot;</span> + err + <span class="hljs-string">&quot;.&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="debugger-关键字"><a href="#debugger-关键字" class="headerlink" title="debugger 关键字"></a>debugger 关键字</h3><p><strong>debugger</strong> 关键字用于停止执行 JavaScript，并调用调试函数。</p><p>这个关键字与在调试工具中设置断点的效果是一样的。</p><p>可以先使用再声明</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0.1</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">0.2</span>;<br><span class="hljs-keyword">let</span> z = x + y            <span class="hljs-comment">// z 的结果为 0.30000000000000004</span><br><span class="hljs-keyword">if</span> (z == <span class="hljs-number">0.3</span>)  <br></code></pre></td></tr></table></figure><p>&#x3D;&gt;用乘除法解决问题</p><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>由于与HTML的表单有关联,因此在这里先简单回顾一下HTML表单</p><p>具体可以参考另一篇笔记<a href="https://404ll.github.io/2024/04/25/%E5%89%8D%E7%AB%AF/HTML%E8%A1%A8%E5%8D%95/">HTML表单</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>表单验证可以包括以下内容：</p><ol><li><strong>必填字段验证</strong>：确保用户填写了表单中标记为必填的字段，防止用户提交空值或默认值。</li><li><strong>格式验证</strong>：检查用户输入的数据格式是否正确，例如邮箱地址、电话号码、日期等。</li><li><strong>长度验证</strong>：检查用户输入的数据长度是否符合要求，如最小长度、最大长度等。</li><li><strong>数据类型验证</strong>：确保用户输入的数据类型正确，如数字、字母、日期等。</li><li><strong>范围验证</strong>：检查数值型数据是否在指定的范围内，如年龄、价格等。</li><li><strong>正则表达式验证</strong>：使用正则表达式对用户输入的数据进行更灵活的验证，可以实现复杂的格式匹配。</li></ol><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x=<span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-string">&quot;myForm&quot;</span>][<span class="hljs-string">&quot;fname&quot;</span>].<span class="hljs-property">value</span>;<br></code></pre></td></tr></table></figure><p>用于获取 HTML 表单中名为 “myForm” 的表单中名为 “fname” 的输入字段的值，并将其存储在变量 x 中。</p><h2 id="验证API"><a href="#验证API" class="headerlink" title="验证API"></a>验证API</h2><h3 id="验证验证和表单验证的区别"><a href="#验证验证和表单验证的区别" class="headerlink" title="验证验证和表单验证的区别"></a>验证验证和表单验证的区别</h3><ol><li><strong>JavaScript 验证 API</strong>：<ul><li>JavaScript 验证 API 是 JavaScript 提供的一组 API 和方法，用于编写自定义的验证逻辑。</li><li>开发人员可以使用 JavaScript 验证 API 编写自己的验证函数，以根据特定的需求对用户输入进行验证。</li><li>这种方式更加灵活，可以实现各种复杂的验证逻辑，但需要编写更多的代码。</li></ul></li><li><strong>表单验证</strong>：<ul><li>表单验证是 HTML 表单元素自带的一种验证机制，可以通过设置一些属性来定义验证规则。</li><li>HTML5 提供了一些内置的表单验证属性，如 <code>required</code>, <code>min</code>, <code>max</code>, <code>pattern</code> 等，可以直接在 HTML 中使用。</li><li>表单验证相对简单，适用于一些基本的验证需求，如必填字段、最小长度、最大长度、正则表达式验证等</li></ul></li></ol><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>我理解的This 表示对<strong>上一级对象</strong>的引用：</p><ul><li><p>方法体内表示对该方法所属的属性的引用</p></li><li><p>单独使用，就是全局对象</p></li><li><p>在函数中，函数的所属者绑定默认到this上（这里和后面学习智能合约有关联）</p></li><li><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素。</p></li></ul><blockquote><p>方法是与对象相关联的函数</p></blockquote><p>在学习教程中看到了一篇笔记，可以帮助理解：</p><blockquote><p>简单理解，this指向的是该this所在的最里层的object对象。</p><p>1、函数不是object对象，所以没有写在object对象里的函数调用this会指向window</p><p>2、构造函数是object对象，所以在构造函数中调用this会指向该构造函数</p><p>3、html元素是object元素，所以在html元素中调用this会指向该元素</p><p>4、函数1 return 函数2，函数2 return this，该this会指向window</p><p>例：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&gt;<span class="hljs-keyword">let</span> obj = &#123;<br>   <span class="hljs-attr">fun1</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>       &#125;<br>   &#125;,<br>&gt;&#125;;<br>&gt;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">fun1</span>()()); <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="javascript-void-0-含义"><a href="#javascript-void-0-含义" class="headerlink" title="javascript:void(0) 含义"></a>javascript:void(0) 含义</h1><p>void 在C语言中也有涉及，表示没有返回值。</p><p>在<strong>javascript:void(0)</strong> 中最关键的是 <strong>void</strong> 关键字， <strong>void</strong> 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p><h3 id="href-”-”与href-”javascript-void-0-”的区别"><a href="#href-”-”与href-”javascript-void-0-”的区别" class="headerlink" title="href&#x3D;”#”与href&#x3D;”javascript:void(0)”的区别"></a>href&#x3D;”#”与href&#x3D;”javascript:void(0)”的区别</h3><ol><li>**href&#x3D;”#”**：<ul><li>这个用法将页面的滚动位置移动到页面顶部。当用户点击链接时，浏览器会尝试滚动到页面中 ID 为 “#” 的元素，而在大多数情况下这个元素并不存在，因此页面会回到顶部。</li><li>使用 <code>href=&quot;#&quot;</code> 会触发页面滚动，有时可能会导致页面跳跃，尤其是在单页应用或具有滚动效果的页面中。</li></ul></li><li>**href&#x3D;”javascript:void(0)”**：<ul><li>这个用法是执行一个 JavaScript 表达式 <code>void(0)</code>，它会返回 undefined，但不会导致页面跳转或滚动。</li><li>使用 <code>href=&quot;javascript:void(0)&quot;</code> 不会触发页面滚动，因此不会导致页面跳跃</li></ul></li></ol><h2 id="promise和异步编程"><a href="#promise和异步编程" class="headerlink" title="promise和异步编程"></a>promise和异步编程</h2><p>**异步编程 ** 通俗来讲就是，不按照顺序执行</p><blockquote><p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败</p></blockquote><p><strong>Promise 构造函数</strong>返回一个 Promise 对象，该对象具有以下几个方法：</p><ul><li>then：用于处理 Promise 成功状态的回调函数。</li><li>catch：用于处理 Promise 失败状态的回调函数。</li><li>finally：无论 Promise 是成功还是失败，都会执行的回调函数。</li></ul><p>感觉大部分学习基于代码会比较清楚：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1111</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3333</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;An error&quot;</span>;<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。</p><p><strong>call()</strong> 和 <strong>apply()</strong> 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p><h3 id="call-与apply-的不同"><a href="#call-与apply-的不同" class="headerlink" title="call()与apply()的不同"></a>call()与apply()的不同</h3><p>apply()的第二个参数是数组，call()是作为参数（从第二个起）单独传入。</p><h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h2><p>有关javascript的初步学习就到这里了，后面主要通过一些比较小的项目来进一步理解和深化学习！</p><p>进阶的补充会继续更新博客，请期待一下！</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
